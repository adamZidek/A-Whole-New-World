'use strict';

function Frustum(l,r,b,t,n,f) {
   var m =  mat4(1);
   m[0][0] = 2 * n / (r - l);
   m[0][1] = 0;
   m[0][2] = (r + l) / (r - l);
   m[0][3] = 0;

   m[1][0] = 0;
   m[1][1] = 2 * n / (t - b);
   m[1][2] = (t + b) / (t - b);
   m[1][3] = 0;

   m[2][0] = 0;
   m[2][1] = 0;
   m[2][2] = -(f + n) / (f - n);
   m[2][3] = -2 * f * n / (f - n);

   m[3][0] = 0;
   m[3][1] = 0;
   m[3][2] = -1;
   m[3][3] = 0;
   
   return m;
}

function MakeCanvas(width, height, locID) {

    if (width == undefined || width < 0) {
       width = 300;
    }

    if (height == undefined || height < 0) {
       height = 300;
    }

    var canvas = document.createElement('canvas')
        canvas.tabIndex = 0;
        canvas.height = height;
        canvas.width = width;
	canvas.style.border = "1px solid #0000FF";

    if(locID == undefined) {
        document.body.appendChild(canvas);
    } else {
        div = document.getElementById(locID);
        if (null == div) {
            document.body.appendChild(canvas);
        } else {
            div.appendChild(canvas);
        }
    }

    document.body.appendChild(canvas);
    return canvas;
}

function InitGL(canvas) {
    var gl =  WebGLUtils.setupWebGL(canvas,'OES_standard_derivatives');
    if (!gl) {
        alert ("WebGL isn't available");
    }

    gl.getExtension('OES_standard_derivatives');
    return gl;
}

function Canvas(width, height, locID) {
    this.disp = MakeCanvas(width, height, locID);

    var gl = InitGL(this.disp);
    this.gl = gl;

    var tmpCanvas = this;
    this.x = this.disp.offsetLeft;
    this.y = this.disp.offsetTop;

    gl.viewport(0,0, width, height);

    this.program = initShaders(gl, "vertex-shader","fragment-shader");
    gl.useProgram(this.program);

    this.mat1Pos = gl.getUniformLocation(this.program, "uMatrix1");
    this.mat2Pos = gl.getUniformLocation(this.program, "uMatrix2");
    this.worldMatPos = gl.getUniformLocation(this.program, "uWorld");
    this.cameraMatPos = gl.getUniformLocation(this.program, "uCamera");
    this.projectionMatPos = gl.getUniformLocation(this.program, "uProject");
    this.edgeColorPos = gl.getUniformLocation(this.program, "uEdgeColor");

    this.Init();
    return this;
}

Canvas.prototype = {

    Init: function() {
        this.gl.clearColor(1.0, 1.0, 1.0, 1.0);

        this.gl.enable(this.gl.BLEND);
	this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

        this.gl.enable(this.gl.DEPTH_TEST);
	this.gl.depthFunc(this.gl.LESS);
	this.gl.depthMask(this.gl.TRUE);

        this.shaderChoice = false;
        this.gl.uniform1f(this.shaderLoc, 0.0);

        this.gl.enable(this.gl.CULL_FACE);
        this.gl.frontFace(this.gl.CCW);
	this.gl.cullFace(this.gl.BACK);

	this.Reset();
    },

    Rotate: function(axis, dir, dvec)
	{
		var delta = .1;
	
		if (dir =='r') 
		{	
			if(this.theta < 360)
			{
				this.theta += 5;
			}
			else
			{
				this.theta = 360;
			}
		}
		else if(dir == 'l')
		{
			if(this.theta > 0)
			{
				this.theta -= 5;
			}
			else
			{
				this.theta = 0;
			}
		}
		console.log(this.theta);
		
        this.RedoProjectionMatrix();
    },

    Reset: function() {
    
    this.theta = 90;
        
        
    this.fov = 90;
    this.ratio = 1.0;
        
	this.xr = 0;
	this.yr = 0;
	this.zr = 0;

    //CAM
	this.ex = 0;
	this.ey = 2;   //2
	this.ez = -20;

	this.atx = 0;
	this.aty = 2;
	this.atz = 0;
	this.RedoCameraMat();

	this.near = 1.8;
	this.far = 30;
	this.left = -3;
	this.right = 3;
	this.high = 3;
	this.bottom = -1;
    
    
    //movement 
	
	this.RedoProjectionMatrix();
    },

    RedoProjectionMatrix: function() {
        
        var mat = perspective(this.fov, this.ratio, this.near, this.far);
        this.gl.uniformMatrix4fv(this.projectionMatPos,false,flatten(mat));
    },

    ChangeNear(dir)
    {
        if(this.near <= 30 && this.near >= .1)
        {
            this.near += dir;  //0.1
            this.near = Math.max(this.near, 0.1)
            
            if(this.near > 30.00)
            {
                this.near = 30.00
            }
            this.RedoProjectionMatrix();
        }
    },

    ChangeWidth(dir) {
        this.left -= dir*0.1;
        this.right += dir*0.1;
	if (this.left == this.right) {
	   this.left -= 0.1;
	   this.right += 0.1;
	}
	this.RedoProjectionMatrix();
    },

    ChangeHeight(dir) {
        this.bottom -= dir*0.1;
        this.high += dir*0.1;
	if (this.high == this.bottom) {
	   this.bottom -= 0.1;
	   this.high += 0.1;
	}
	this.RedoProjectionMatrix();
    },

    MoveCamera: function(dvec, rot) {
        var posDelta = 1;
		var radians = (this.theta * (Math.PI/180));

		if(this.ex > -100 && this.ex < 100 && this.ez > -100 && this.ez < 100)
		{
			if(dvec[2] > 0)
			{
				this.ex +=  posDelta * Math.cos(radians);
				this.ez +=  posDelta * Math.sin(radians);
				this.atx +=  posDelta * Math.cos(radians);
				this.atz += posDelta * Math.sin(radians);
			}
			else if(dvec[2] < 0)
			{
				this.ex -=  posDelta * Math.cos(radians);
				this.ez -=  posDelta * Math.sin(radians);
				this.atx -=  posDelta * Math.cos(radians);
				this.atz -= posDelta * Math.sin(radians)
			}
		}
		if(this.ex >= 99)
		{
			this.ex = 99;
		}
		if(this.ex <= -99)
		{
			this.ex = -99;
		}
		if(this.ez >= 99)
		{
			this.ez = 99;
		}
		if(this.ez <= -99)
		{
			this.ez = -99;
		}

        this.RedoCameraMat(); 
    },

    MoveEye: function(dvec) {
        var posDelta = 1;

        this.atx += dvec[0]*posDelta; 
        this.aty += dvec[1]*posDelta; 
        this.RedoCameraMat(); 
    },

    RedoCameraMat: function() {
        var cameraMatrix = lookAt([this.ex, this.ey, this.ez], 
	                           [this.atx, this.aty, this.atz], 
				   [0,1,0]);
        this.gl.uniformMatrix4fv(this.cameraMatPos,false,flatten(cameraMatrix));
    },
    
    ChangeFOV: function(amt)
    {
        if(this.fov <= 180 && this.fov >= 20)
        {
            this.fov += amt;
            this.fov = Math.max(this.fov, 0.1)
            
            if(this.fov < 20)
            {
                this.fov = 20;
            }
            if(this.fov > 180)
            {
                this.fov = 180;
            }
            this.RedoProjectionMatrix();
        }
    },
    
    ChangeAspect: function(amt)
    {
        if(this.ratio >= .1 && this.ratio <= 2.0)
        {
            this.ratio += amt;
            this.RedoProjectionMatrix();
            
            if(this.ratio < .1)
            {
                this.ratio = .1;
            }
            if(this.ratio > 2.0)
            {
                this.ratio = 2.0;
            }
            this.RedoProjectionMatrix();
        }
    },


    Redisplay: function() {
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

	var transform = mat4(1);
	transform = mult(transform, rotate(this.xr, [1,0,0]));
	transform = mult(transform, rotate(this.yr, [0,1,0]));
	transform = mult(transform, rotate(this.zr, [0,0,1]));
        this.gl.uniformMatrix4fv(this.worldMatPos,false, flatten(transform ));
        return;
    },

    GetCamera: function() {
        return ([this.ex, this.ey, this.ez]);
    },

    GetLookAt: function() {
        return ([this.atx, this.aty, this.atz]);
    },

    GetLR: function() {
        return ([this.left, this.right]);
    },

    GetTB: function() {
        return ([this.high, this.bottom]);
    },

    GetNF: function() {
        return ([this.near, this.far]);
    },
    
    GetFOV: function() {
        return (this.fov);
    },
    
    GetRatio: function(){
        return (this.ratio);
    }
};
